// Generated by gencpp from file custom_msgs/OdometryWithPointCloud.msg
// DO NOT EDIT!

#ifndef CUSTOM_MSGS_MESSAGE_ODOMETRYWITHPOINTCLOUD_H
#define CUSTOM_MSGS_MESSAGE_ODOMETRYWITHPOINTCLOUD_H

#include <map>
#include <string>
#include <vector>

#include "MessageType/geometry_msgs/Point32.h"
#include "MessageType/sensor_msgs/ChannelFloat32.h"
#include "MessageType/std_msgs/Header.h"

#include "MessageType/nav_msgs/Odometry.h"
#include "MessageType/sensor_msgs/PointCloud.h"
#include "MessageType/std_msgs/Header.h"

namespace ob_slam {
namespace custom_msgs {
    template <class ContainerAllocator>
    struct OdometryWithPointCloud_ {
        typedef OdometryWithPointCloud_<ContainerAllocator> Type;

        OdometryWithPointCloud_()
            : header()
            , odometry()
            , point_cloud()
        {
        }
        OdometryWithPointCloud_(const ContainerAllocator& _alloc)
            : header(_alloc)
            , odometry(_alloc)
            , point_cloud(_alloc)
        {
            (void)_alloc;
        }

        typedef std_msgs::Header_<ContainerAllocator> _header_type;
        _header_type header;

        typedef nav_msgs::Odometry_<ContainerAllocator> _odometry_type;
        _odometry_type odometry;

        typedef sensor_msgs::PointCloud_<ContainerAllocator> _point_cloud_type;
        _point_cloud_type point_cloud;

        typedef std::shared_ptr<custom_msgs::OdometryWithPointCloud_<ContainerAllocator>> Ptr;
        typedef std::shared_ptr<custom_msgs::OdometryWithPointCloud_<ContainerAllocator> const> ConstPtr;

    }; // struct OdometryWithPointCloud_

    typedef custom_msgs::OdometryWithPointCloud_<std::allocator<void>> OdometryWithPointCloud;

    typedef std::shared_ptr<custom_msgs::OdometryWithPointCloud> OdometryWithPointCloudPtr;
    typedef std::shared_ptr<custom_msgs::OdometryWithPointCloud const> OdometryWithPointCloudConstPtr;

    // constants requiring out of line definition

    template <typename ContainerAllocator>
    std::ostream& operator<<(std::ostream& s, const custom_msgs::OdometryWithPointCloud_<ContainerAllocator>& v)
    {
        ob_slam::message_operations::Printer<custom_msgs::OdometryWithPointCloud_<ContainerAllocator>>::stream(s, "", v);
        return s;
    }

    template <typename ContainerAllocator1, typename ContainerAllocator2>
    bool operator==(const custom_msgs::OdometryWithPointCloud_<ContainerAllocator1>& lhs, const custom_msgs::OdometryWithPointCloud_<ContainerAllocator2>& rhs)
    {
        return lhs.header == rhs.header && lhs.odometry == rhs.odometry && lhs.point_cloud == rhs.point_cloud;
    }

    template <typename ContainerAllocator1, typename ContainerAllocator2>
    bool operator!=(const custom_msgs::OdometryWithPointCloud_<ContainerAllocator1>& lhs, const custom_msgs::OdometryWithPointCloud_<ContainerAllocator2>& rhs)
    {
        return !(lhs == rhs);
    }

} // namespace custom_msgs
}

namespace ob_slam {
namespace message_traits {

    template <class ContainerAllocator>
    struct IsFixedSize<custom_msgs::OdometryWithPointCloud_<ContainerAllocator>>
        : FalseType {
    };

    template <class ContainerAllocator>
    struct IsFixedSize<custom_msgs::OdometryWithPointCloud_<ContainerAllocator> const>
        : FalseType {
    };

    template <class ContainerAllocator>
    struct IsMessage<custom_msgs::OdometryWithPointCloud_<ContainerAllocator>>
        : TrueType {
    };

    template <class ContainerAllocator>
    struct IsMessage<custom_msgs::OdometryWithPointCloud_<ContainerAllocator> const>
        : TrueType {
    };

    template <class ContainerAllocator>
    struct HasHeader<custom_msgs::OdometryWithPointCloud_<ContainerAllocator>>
        : TrueType {
    };

    template <class ContainerAllocator>
    struct HasHeader<custom_msgs::OdometryWithPointCloud_<ContainerAllocator> const>
        : TrueType {
    };

    template <class ContainerAllocator>
    struct MD5Sum<custom_msgs::OdometryWithPointCloud_<ContainerAllocator>> {
        static const char* value()
        {
            return "0a18fcff261def39e1bb640bb003b14f";
        }

        static const char* value(const custom_msgs::OdometryWithPointCloud_<ContainerAllocator>&) { return value(); }
        static const uint64_t static_value1 = 0x0a18fcff261def39ULL;
        static const uint64_t static_value2 = 0xe1bb640bb003b14fULL;
    };

    template <class ContainerAllocator>
    struct DataType<custom_msgs::OdometryWithPointCloud_<ContainerAllocator>> {
        static const char* value()
        {
            return "custom_msgs/OdometryWithPointCloud";
        }

        static const char* value(const custom_msgs::OdometryWithPointCloud_<ContainerAllocator>&) { return value(); }
    };

    template <class ContainerAllocator>
    struct Definition<custom_msgs::OdometryWithPointCloud_<ContainerAllocator>> {
        static const char* value()
        {
            return "std_msgs/Header header\n"
                   "nav_msgs/Odometry odometry\n"
                   "sensor_msgs/PointCloud point_cloud\n"
                   "================================================================================\n"
                   "MSG: std_msgs/Header\n"
                   "# Standard metadata for higher-level stamped data types.\n"
                   "# This is generally used to communicate timestamped data \n"
                   "# in a particular coordinate frame.\n"
                   "# \n"
                   "# sequence ID: consecutively increasing ID \n"
                   "uint32 seq\n"
                   "#Two-integer timestamp that is expressed as:\n"
                   "# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
                   "# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
                   "# time-handling sugar is provided by the client library\n"
                   "time stamp\n"
                   "#Frame this data is associated with\n"
                   "string frame_id\n"
                   "\n"
                   "================================================================================\n"
                   "MSG: nav_msgs/Odometry\n"
                   "# This represents an estimate of a position and velocity in free space.  \n"
                   "# The pose in this message should be specified in the coordinate frame given by header.frame_id.\n"
                   "# The twist in this message should be specified in the coordinate frame given by the child_frame_id\n"
                   "Header header\n"
                   "string child_frame_id\n"
                   "geometry_msgs/PoseWithCovariance pose\n"
                   "geometry_msgs/TwistWithCovariance twist\n"
                   "\n"
                   "================================================================================\n"
                   "MSG: geometry_msgs/PoseWithCovariance\n"
                   "# This represents a pose in free space with uncertainty.\n"
                   "\n"
                   "Pose pose\n"
                   "\n"
                   "# Row-major representation of the 6x6 covariance matrix\n"
                   "# The orientation parameters use a fixed-axis representation.\n"
                   "# In order, the parameters are:\n"
                   "# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)\n"
                   "float64[36] covariance\n"
                   "\n"
                   "================================================================================\n"
                   "MSG: geometry_msgs/Pose\n"
                   "# A representation of pose in free space, composed of position and orientation. \n"
                   "Point position\n"
                   "Quaternion orientation\n"
                   "\n"
                   "================================================================================\n"
                   "MSG: geometry_msgs/Point\n"
                   "# This contains the position of a point in free space\n"
                   "float64 x\n"
                   "float64 y\n"
                   "float64 z\n"
                   "\n"
                   "================================================================================\n"
                   "MSG: geometry_msgs/Quaternion\n"
                   "# This represents an orientation in free space in quaternion form.\n"
                   "\n"
                   "float64 x\n"
                   "float64 y\n"
                   "float64 z\n"
                   "float64 w\n"
                   "\n"
                   "================================================================================\n"
                   "MSG: geometry_msgs/TwistWithCovariance\n"
                   "# This expresses velocity in free space with uncertainty.\n"
                   "\n"
                   "Twist twist\n"
                   "\n"
                   "# Row-major representation of the 6x6 covariance matrix\n"
                   "# The orientation parameters use a fixed-axis representation.\n"
                   "# In order, the parameters are:\n"
                   "# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)\n"
                   "float64[36] covariance\n"
                   "\n"
                   "================================================================================\n"
                   "MSG: geometry_msgs/Twist\n"
                   "# This expresses velocity in free space broken into its linear and angular parts.\n"
                   "Vector3  linear\n"
                   "Vector3  angular\n"
                   "\n"
                   "================================================================================\n"
                   "MSG: geometry_msgs/Vector3\n"
                   "# This represents a vector in free space. \n"
                   "# It is only meant to represent a direction. Therefore, it does not\n"
                   "# make sense to apply a translation to it (e.g., when applying a \n"
                   "# generic rigid transformation to a Vector3, tf2 will only apply the\n"
                   "# rotation). If you want your data to be translatable too, use the\n"
                   "# geometry_msgs/Point message instead.\n"
                   "\n"
                   "float64 x\n"
                   "float64 y\n"
                   "float64 z\n"
                   "================================================================================\n"
                   "MSG: sensor_msgs/PointCloud\n"
                   "# This message holds a collection of 3d points, plus optional additional\n"
                   "# information about each point.\n"
                   "\n"
                   "# Time of sensor data acquisition, coordinate frame ID.\n"
                   "Header header\n"
                   "\n"
                   "# Array of 3d points. Each Point32 should be interpreted as a 3d point\n"
                   "# in the frame given in the header.\n"
                   "geometry_msgs/Point32[] points\n"
                   "\n"
                   "# Each channel should have the same number of elements as points array,\n"
                   "# and the data in each channel should correspond 1:1 with each point.\n"
                   "# Channel names in common practice are listed in ChannelFloat32.msg.\n"
                   "ChannelFloat32[] channels\n"
                   "\n"
                   "================================================================================\n"
                   "MSG: geometry_msgs/Point32\n"
                   "# This contains the position of a point in free space(with 32 bits of precision).\n"
                   "# It is recommeded to use Point wherever possible instead of Point32.  \n"
                   "# \n"
                   "# This recommendation is to promote interoperability.  \n"
                   "#\n"
                   "# This message is designed to take up less space when sending\n"
                   "# lots of points at once, as in the case of a PointCloud.  \n"
                   "\n"
                   "float32 x\n"
                   "float32 y\n"
                   "float32 z\n"
                   "================================================================================\n"
                   "MSG: sensor_msgs/ChannelFloat32\n"
                   "# This message is used by the PointCloud message to hold optional data\n"
                   "# associated with each point in the cloud. The length of the values\n"
                   "# array should be the same as the length of the points array in the\n"
                   "# PointCloud, and each value should be associated with the corresponding\n"
                   "# point.\n"
                   "\n"
                   "# Channel names in existing practice include:\n"
                   "#   \"u\", \"v\" - row and column (respectively) in the left stereo image.\n"
                   "#              This is opposite to usual conventions but remains for\n"
                   "#              historical reasons. The newer PointCloud2 message has no\n"
                   "#              such problem.\n"
                   "#   \"rgb\" - For point clouds produced by color stereo cameras. uint8\n"
                   "#           (R,G,B) values packed into the least significant 24 bits,\n"
                   "#           in order.\n"
                   "#   \"intensity\" - laser or pixel intensity.\n"
                   "#   \"distance\"\n"
                   "\n"
                   "# The channel name should give semantics of the channel (e.g.\n"
                   "# \"intensity\" instead of \"value\").\n"
                   "string name\n"
                   "\n"
                   "# The values array should be 1-1 with the elements of the associated\n"
                   "# PointCloud.\n"
                   "float32[] values\n";
        }

        static const char* value(const custom_msgs::OdometryWithPointCloud_<ContainerAllocator>&) { return value(); }
    };

} // namespace message_traits
} // namespace ob_slam

namespace ob_slam {
namespace serialization {

    template <class ContainerAllocator>
    struct Serializer<custom_msgs::OdometryWithPointCloud_<ContainerAllocator>> {
        template <typename Stream, typename T>
        inline static void allInOne(Stream& stream, T m)
        {
            stream.next(m.header);
            stream.next(m.odometry);
            stream.next(m.point_cloud);
        }

        ROS_DECLARE_ALLINONE_SERIALIZER
    }; // struct OdometryWithPointCloud_

} // namespace serialization
} // namespace ob_slam

namespace ob_slam {
namespace message_operations {

    template <class ContainerAllocator>
    struct Printer<custom_msgs::OdometryWithPointCloud_<ContainerAllocator>> {
        template <typename Stream>
        static void stream(Stream& s, const std::string& indent, const custom_msgs::OdometryWithPointCloud_<ContainerAllocator>& v)
        {
            s << indent << "header: ";
            s << std::endl;
            Printer<std_msgs::Header_<ContainerAllocator>>::stream(s, indent + "  ", v.header);
            s << indent << "odometry: ";
            s << std::endl;
            Printer<nav_msgs::Odometry_<ContainerAllocator>>::stream(s, indent + "  ", v.odometry);
            s << indent << "point_cloud: ";
            s << std::endl;
            Printer<sensor_msgs::PointCloud_<ContainerAllocator>>::stream(s, indent + "  ", v.point_cloud);
        }
    };

} // namespace message_operations
} // namespace ob_slam

#endif // CUSTOM_MSGS_MESSAGE_ODOMETRYWITHPOINTCLOUD_H
